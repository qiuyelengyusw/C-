一、

1.

.cs 类



2.

引用命名空间



3.

Main函数是程序的主入口，程序写在Main函数下才可被执行



4.

.sln : 解决方案文件

.csproj :项目文件



二、

1.

Console,WriteLine("要打印的内容");

Console,ReadKey();//暂停当前程序，等待用户按下任意键继续



三、

1.Ctrl+K+D 快速对齐

2.Shift+Home Shift+End

3.Ctrl+K+C注释选中的代码

4.Ctrl+K+U取消注释选中的代码

5.折叠冗余代码: #region #endregion



四、

1.

储存整数100

数据类型：整数

在内存中开辟的空间应该是整数类型 int



2.

存储变量的语法：

变量类型 变量名;

变量名=值;



3."="在这里并不表示等于，而是赋值，表示把等号右边的值赋值给等号

左边的变量



4.数据类型

1）、整数类型：int 只能存储整数，不能存储小数。

2）、小数类型：double 既能存储整数，也能存储橡树，小数点后面的位

数 15~16位。

3）、金钱类型：decimal 用来存储金钱，值后面需要加上一个m。

4）、字符串类型：string 用来存储多个文本，也可以存储空，字符串类

型需要被双引号引起来

5）、字符类型：char 用来存储单个字符，最多最少只能有一个字符，不

能储存空，字符类型的值需要用单引号引起来



三、

1.给变量命名的时候要满足两个规范：

1）、Camel 骆驼命名规范，要求变量名首单词的首字母要小写，其余每

个单词的首字母要大写，多用于给变量或字段命名。

highSchoolStudent

2）、Pascal 命名规范：要求每个单词的首字母都要大写，其余字母小写，

多用于给类或者方法命名。

HighSchoolStudent



2.赋值运算符

=; 表示赋值的意思，表示把等号右边的值赋值给等号左边的变量。

由等号连接的表达式称之为赋值表达式。

注意：每个表达式我们都可以求解除一个定值，对于赋值表达式而言，等

号左边的变量的值，就是整个赋值表达式的值。

int number=10;



3.+号的作用

1）、连接：当+号两边有一边是字符串的时候，+号就起到连接的作用

2）、相加：当+两边是数字的时候，+号就起到相加的作用



4.占位符

使用方法：先挖个坑，再填个坑。

使用占位符需要注意的地方：

1、你挖了几个坑，就填几个坑，如果你多填了，没效果

               如果你少填了，报异常

2、输出顺序：按照挖坑的顺序输出



3.异常

异常是指：语法上没有任何错误，只不过在程序运行期间，由于某些原因

出现了问题，使程序不能再正常运行，也被称作Bug



4.转义符

转义符值得就是一个'\'+一个特殊的字符，组成了一个具有特殊含义的字

符。



\n 表示换行

\" 表示一个英文半角的双引号

\t 表示一个TAB键的空格

\b 表示一个退格键，放到字符串的两边没有效果

\\ 表示一个\



@符号

1.取消\在字符串中的转义作用

2.将字符串按照编辑的原格式输出



5.算数运算符

+

-

*

/

%



6.类型转换

隐式类型转换：

我们要求等号两边参与运算的操作书的类型必须一致，如果不一致，满足

下列条件会发生自动类型转换，或者称之为隐式类型转换。

两种类型兼容

列如：int 和 double 兼容（都是数字类型）

目标类型大于原类型

列如：double > int （小的转大的)



显式类型转换：

1.两种类型相兼容 int-->double

2.大的转成小的 double-->int

语法：

（待转换的类型）要转换的值；



总结：

自动类型转换：int-->double

显示类型转换：double-->int



五、

1.如果两个变量的类型相兼容，可以使用自动类型转换或者强制类型转换，

但是，如果两个类型的变量不兼容，比如 string 和 int，这时候我们可

以使用一个叫做Convert的转换工厂进行转换。

注意：使用Convert进行转换，也要满足一个条件：

面上要过的去，比如：

string a = "123"// 可以转成 int 或 double

string b = "123abc"//不可以转成 int 或 double



2.算数运算符

++：分为前++和后++，不管是前++还是后++，最终的结果都是给这

个变量加一。

去别表现在表达式当中，如果是前++，则先给这个变量自身加一，然后

带着这个加一后的值去参与运算。

如果是后++，则先拿原值参与运算，运算完成后，再将这个变量自身加

一。

--：同上。



3.

对于像++或--这样只需要一个操作数就能完成的运算，我们称之为一元

运算符。

+ - * / %对于这些需要两个或以上才能完成运算的操作符，我们称之为

二元运算符。

一元运算符的优先级要高于二元运算符。

如果在一个表达式当中，既有一元运算符，又有二元运算符，我们首先计

算一元运算符。



4.关系运算符

>

<

>=

<=

==

!=

关系运算符是用来描述两个事物之间的关系

由关系运算符连接的表达式称之为关系表达式。



5.bool类型

在c#中我们用bool类型来描述对或者错。

bool类型的值只有两个 一个true 一个false



6.逻辑运算符

&&逻辑与

||逻辑或

!逻辑非



逻辑运算符两边放的一般都是关系表达式或者bool类型的值

5>3&&true



3>5||false



!表达式

逻辑表达式的结果同样也是bool类型



7.复合赋值运算符

+=

-=

*=

/=

%=



8.顺序结构：程序从Main函数进入，从上到下一行一行的执行，不会落下

任何一行。

分支结构：if if-else

选择结构：if else-if switch-case

循环结构：while do-while for foreach



9.if语句：

语法：

if(判断条件)

{

	要执行的代码;

}

判断条件：一般为关系表达式或者bool类型的值。

执行过程：程序运行到if处，首先判断if所带的小括号中的判断条件，

如果条件成立，也就是返回true，则执行if收带的大括号中的代码，

如果判断条件不成立，也就是返回一个false，则跳过if结构，继续向下

执行。



if结构的特点，先判断，再执行，有可能一行代码都不执行

用于一种情况的判断



如果你想表示的含义是当b的值为true的时候去执行if中的代码，

那么语法上==true可以省略

但是，如果你想表达的是当b==false的时候去执行if中的代码，

语法上==false不能省略



10.if-else

语法：

if(判断条件)

{

	执行的代码;

}

else

{

	执行的代码;

}

执行过程：程序执行到if处，首先判断if所带的小括号中的判断条件是否

成立，

如果成立，也就是返回一个true，则执行if所带的大括号中的代码，

执行完成后，跳出if结构。

如果if所带的小括号中的判断条件不成立，也就是返回一个false，

则跳过if语句，执行else所带的大括号中的语句，执行完成后，

跳出if-else结构。



if-else结构的特点：先判断，再执行，最少都要执行一条代码。

用于两种情况的判断



10.if else-if

作用：用来处理多条件的区间性的判断。

语法：

if(判断条件)

{

	要执行的代码;

}

else if(判断条件)

{

	要执行的代码;

}

else if(判断条件)

{

	要执行的代码;

}

else if(判断条件)

{

	要执行的代码;

}

......

else

{

	要执行的代码;

}

执行过程：程序首先判断第一个if所带的小括号中的判断条件，如果条件

成立，也就是返回一个true，

则执行该if所带的大括号中的代码，执行完成后，立即跳出if else-if

结构。

如果第一个if所带的判断条件不成立，也就是返回一个false，则继续向

下进行判断，依次的判断每一个if的判断条件，如果成立，就执行该if所

带的大括号中的代码，如果不成立，则继续行侠判断，

如果每个if所带的判断条件都不成立，就看当前这个if else-if结构中是

否存在else。

如果有else的话，则执行else中所带的代码，如果没有else，则整个

if else-if结构什么都不做。

else可以省略。



1)、程序调试

1)、写完一段程序后，想看一下这段程序的执行过程

2)、当你写完这段程序后，发现程序并没有按照你想象的样子去执行



调试方法：

1)、F11逐语句调试（单步调试）

2)、F10逐过程调试

3)、断点调试



2、for循环

语法：

for(表达式1;表达式2;表达式3;)

{

	循环体;

}

表达式1一般为声明循环变量，记录循环的次数(int i=0;)

表达式2一般为循环条件(i<10)

表达式3一般为改变循环条件的代码，使循环条件终有一天不在成立(i++)

执行过程：程序首先执行表达式1，声明了一个循环变量用来记录循环的次数，

然后执行表达式2，判断循环条件是否成立，如果表达式2返回的结果为true，

则执行循环体，如果不成立，则跳出for循环。



4、三元表达式

语法：

表达式1?表达式2:表达式3;

表达式1一般为一个关系表达式。

如果表达式1的值为true，那么表达式2的值就是整个三元表达式的值。

如果表达式1的值为false，那么表达式3的值就是整个三元表达式的值。

注意：表达式2的结果必须跟表达式3的结果类型一致，并且也要跟整个三元表

达式的结果类型一致。



1、常量

声明常量的语法：

const 变量类型 变量名=值;



6、枚举

语法：

[public] enum 枚举名

{

	值1,

	值2,

	值3,

	......

}

public：访问修饰符，公开的公共的，哪儿都可以访问。

enum：关键字，声明枚举的关键字

枚举名：要符合Pascal命名规范



将枚举声明到命名空间下面，类的外面，表示这个命名空间下，所有的类都可

以使用这个枚举



枚举就是一个变量类型，只是枚举声明、赋值、使用的方式跟那些普通的变量

类型不一样



7、所有的类型都能转换成string类型，调用ToString()



8、结构

可以帮助我们一次性声明多个不同类型德变量。

语法：

[public] struct 结构名

{

	成员;//字段

}

变量在程序运行期间只能存储一个值，而字段可以存储多个值。



9、数组

一次性存储多个相同类型的变量。

语法：

数组类型[] 数组名=new 数组类型[数组长度];



10、冒泡排序：就是将一个数组中的元素按照从大到小或者从小到大的顺序进

行排列。



11、方法

函数就是将一堆代码进行重用的一种机制。

函数的语法：

[public] static 返回值类型 方法名([参数列表])

{

	方法体;

}

public：访问修饰符，公开的，公共的，哪儿都可以访问。

static：静态的

返回值类型：如果不需要返回值，写void

方法名：pascal 每个单词的首字母都大写，其余字母小写

参数列表：完成这个方法所必须要提供给这个方法的条件，如果没有参数，小

括号也不能省略。



方法写好后，如果想要被执行，必须要在Main()函数中调用。

方法的调用语法：

类名.方法名();



12、return

1.在方法中返回要返回的值。

2.立即结束本次方法。



一、我们在Main()函数中，调用Test()函数，我们管Main()函数称之为调用者，

管Test()函数称之为被调用者。

如果被调用者想要得到调用者的值：

1.传递参数。

2.使用静态字段来模拟全局变量。

1.返回值



二、不管是形参还是实参，都是在内存中开辟了空间的。



三、方法的功能一定要单一。

方法中最忌讳的就是出现让用户输入等字眼



四、out、ref、params

1.out参数。

如果你在一个方法中，返回多个相同类型的值的时候，可以考虑返回一个数组。

但是，如果返回多个不同类型的值的时候，返回数组就不行了，那么这个时候，我们可以考虑使用out参数。

out参数就侧重于在一个方法中可以返回多个不同类型的值。



2.ref参数

能够将一个变量带入一个方法中进行改变，改变完成后，再将改变后的值带出方法。

ref参数要求在方法外必须为其赋值，而方法内可以不赋值。



3.params可变参数

将实参列表中跟可变参数类型一致的元素都当作数组的元素去处理。

params可变参数必须是形参列表中的最后一个元素。



五、方法的重载

概念：方法的重载指的就是方法的名称相同，但是参数不同。

1.如果参数的个数相同，那么参数的类型就不能相同。

2.如果参数的类型相同，那么参数的个数就不能形同。

*方法的重载跟返回值没有关系。



六、方法的递归



方法自己调用自己。



找出一个文件夹中所有的文件。



一、面向过程------>面向对象



面向过程：面向的是完成这件事的过程，强调的是完成这件事的动作



1.打开冰箱门

2.把大象塞进冰箱

3.关闭冰箱门



如果我们用面向过程的思想来解决这件事儿，当执行这件事的人不同的时候，我们需要为每一个不同的人量身定做解决事情的方法





面向对象：找个对象帮你做事

把大象塞进冰箱里

1.冰箱门可以被打开

2.大象可以被塞进冰箱里

3.冰箱门可以被关闭



面向对象意在写出一个通用的代码，屏蔽差异





关门

面向过程：关门

张三：一脚把门踹紧了

李四：轻轻的把门带上了

王五：门没关严，留了个尾巴



面向对象：关门

门可以被关闭





姓名：孙全

特征：

性别：男

身高：180cm

体重：70kg

年龄：22岁

行为：

吃喝拉撒睡一切正常 健康

吃喝嫖赌抽



特征：

姓名：颜德伟

性别：男

身高：160cm

体重：60kg

年龄：18

行为：

脑残 身体健康





我们在代码中描述一个对象，通过描述这个对象的属性和方法

对象必须是看的见摸得着的



灯：属性和方法

属性：

外形：圆的

功耗：500w

颜色：白色

牌子：xx

方法：发光



电风扇：属性、方法

外形：三个叶片

颜色：白色

品牌：xx

方法：转动、扇风





我们把这些具有相同属性和相同方法的对象进行进一步的封装，抽象出来“类”这个概念

类是一张图纸，确定了对象具有的属性和方法

对象是根据类创建出来的

类就是一个盖大楼的图纸，对象就是盖出来的大楼



2、类

语法：

[public] class <类名>

{

	字段;

	属性;

	方法;

}

写好了一个类后，我们需要创建这个类的对象，

我们称创建这个类的过程叫做实例化。

使用关键字new



this：表示当前这个类的对象

类是不占内存的，而对象是占内存的





3、属性

属性的作用就是保护字段、对字段的赋值和取值进行限定

属性的本质就是两个方法，一个叫 get ( ) 一个叫 set ( ) 

既有get( )也有set( )我们称之为可读可写属性

只有get( )没有set( )我们称之为只读属性

没有get( )只有set( )我们称之为只写属性





Field 字段

Method 方法

property 属性



4、访问修饰符

public：公开的公共的，在哪儿都能访问。

private：私有的，只能在当前类内部进行访问，出了这个类就访问不到了



5、

当我们创建好一个类的对象后。需要给这个对象的每个属性去赋值

我们管这个过程称之为对象的初始化



6、静态和非静态的区别

1.在非静态类中，既可以有实例成员（非静态成员），也可以有静态成员

2.在调用实例成员的时候，需要使用对象名.实例成员；

  在调用静态成员的时候，需要使用类名.静态成员名；

总结：静态成员必须使用类名去调用，而实例成员使用对象名调用。

     静态函数中，只能访问静态成员，不允许访问实例成员。

     静态函数中，既可以使用静态成员，也可以使用实例成员

     静态类中只允许有静态成员，不允许出现实例成员



使用：

1.如果你想要你的类当作一个“工具类”去使用，这个时候可以考虑将类写成静态的

2.静态类在整个项目中资源共享

只有在程序结束之后，静态类才会释放资源



堆	栈	静态存储区



释放资源 GC Garbage Collection 垃圾回收器



7、构造函数

作用：帮助我们初始化对象（给对象的每个属性依次的赋值）

构造函数是一个特殊的方法：

1.构造函数没有返回值，连void也不能写。

2.构造函数的名称必须和类名一样。



创建对象的时候会执行构造函数

构造函数是可以重载的

***

类当中会有一个默认的无参数的构造函数，当你写了一个新的构造函数之后，不管是不是无参数的，那个默认的无参数的构造函数都被干掉了。



8、new关键字

Person zsPerson=new Person( );

new帮我们做了3件事儿：

1.在内存中开辟一块空间

2.在开辟的空间中创建对象

3.调用对象的构造函数进行初始化对象



9、this关键字

1.代表当前类的对象

2.在类当中显示的调用本类的构造函数	:this



10、析构函数

当程序结束时，析构函数才执行，帮助我们释放资源，不写析构函数GC会自动清理释放资源

语法：

~类名( ) { }



二、面向对象继承



1、命名空间

可以认为类是属于命名空间的。

如果在当前项目中没有这个类的命名空间，需要我们手动导入这个类所在的命名空间（类似C语言的头文件，python里的import）



2、在一个项目中引用另一个项目的类

1.添加引用

2.引用命名空间



3、值传递和引用传递

区别

1.值传递和引用传递在内存上存储的地方不一样。

2.在传递值类型和传递引用类型的时候，传递的方式不一样。

值类型我们称之为值传递，引用类型我们称之为引用传递。

目前学过的值类型和引用类型：

值类型：int、double、bool、char、decimal、struct、enum

引用类型：string、数组、自定义类

存储：

值类型的值是存储在内存的栈当中的。

引用类型的值是存储在内存的堆中的。



3、字符串

1.字符串的不可变性

当你给一个字符串重新赋值之后，旧值并没有被销毁，而是重新开辟一块内存空间存储新值。



当程序结束后，GC扫描整个内存，如果发现有的空间没有被指向，则立即把它销毁。



2.我们可以将字符串看作是char类型的一个只读数组。

ToCharArray( );将字符串转换为char数组

new string( char[ ] chs);能够将char数组转换为字符串



4、字符串提供的各种方法

1.Length：获得当前字符串中字符的个数

2.ToUpper( )将字符串转换为大写形式

3.ToLower( )将字符串转换为小写形式

4.Equals(lessonTwo,StringComparison.OrdinalIgnoreCase)比较两个字符串，并忽略大小写

5.Split( )分割字符串，返回字符串类型的数组

6.Substring( )截取字符串，在截取的时候包含要截取的那个位置

7.Indexof( )判断某个字符串中第一次出现的位置，如果没有则返回-1

8.LastIndexOf( )确定字符串中最后一次出现的字符串，如果没有则返回-1

9.StartsWith( )判断以...开始，结束:判断以…结束

11. Replace( )将字符串中某个字符替换成一个新的字符串

12.Contains( )确定字符串是否包含指定的字符串

13.Trim( )去掉字符串中前后的空格

14.TrimEnd( )去掉字符串后面的空格

15.TrimStart( )去掉字符串前面的空格

16.isnulloempty( )确定字符串是空的还是null

17.string.Join( )将数组按照指定的字符串连接并返回一个字符串



5、继承

我们可能会在一些类中，写一些重复的成员，我们可以将这些重复的成员，单独的封装到一个类中，作为这些类的父类。

Student、Teacher、Driver 子类 派生类

Person                父类 基类

子类继承了父类，子类从父类那里继承过来了什么？

首先，子类继承了父类的属性和方法，但是子类并没有继承父类的私有字段。

问题：子类有没有继承父类的构造函数？

答：子类没有继承父类的构造函数，但是，子类会默认的调用父类的无参数的构造函数，创建父类对象，让子类可以使用父类中的成员。

所以，如果在父类中重写了一个有参数的构造函数之后，那个无参数的就被干掉了，子类就调用不到了，所以子类会报错。

解决办法：

1.在父类中重新写一个无参数的构造函数。

2.在子类中显示的调用父类的构造函数，使用关键字：base( )



6、继承的特性

1.继承的单根性：一个子类只能有一个父类。

2.继承的传递性



7、查看类图



8、object是所有类的基类。



9、new关键字

1.创建对象

2.隐藏从父类那里继承过来的同名成员

隐藏的后果就是子类调用不到父类的成员



三、



1、里氏转换

1）子类可以赋值给父类：如果有一个地方需要一个父类作为参数，我们可以给一个子类代替

2）如果父类中装的是子类对象，那么可以将这个父类强转为子类对象，



2、

子类对象可以调用父类中的成员，但是父类对象永远都只能调用自己的成员。



3、

is：表示类型转换，如果能够转换成功，则返回一个true，否则返回一个false

as：表示类型转换，如果能够转换则返回对应的对象，否则返回一个null



4、protected修饰符

protected：受保护的，可以在当前类的内部以及该类的子类中访问



5、List泛型集合

创建泛型集合的对象

List<Type> list = new List<Type>();



6、ArrayList集合

1）集合与数组的区别

集合：很多数据的一个集合

数组：长度不可变、类型单一

集合的好处：长度可以任意改变，类型任意



2）ToString的问题

我们将一个对象输出到控制台 默认情况下 打印的就是这个对象所在的类的命名空间



3）ArrayList的方法

list.Clear();//清空所有元素

list.Remove(true);//删除单个元素，写谁就删谁

list.RemoveAt(0);//根据下标删除元素

list.RemoveRange(0, 3);//根据下标去移除一定范围的元素

list.Sort();//升序排列

list.Reverse();//反转

list.Insert(0,'我');//插入单个元素

list.InsertRange(5, new string[] {"张三","李四"});//在指定的位置插入一个集合



4）长度的问题

每次集合中实际包含的元素个数(count)超过了可以包含的元素个数(capcity)的时候，集合就会向内存中多开辟一倍的内存空间，来保证集合的长度一直够用。



7、Hashtable键值对集合

﻿
125.Hashtable集合 P125 - 00:14
﻿

在键值对集合中，是根据键去找值的

例如通过字典找字   sun --> 孙，拼音是“键”，找出来的字是“值”

键值对对象[键]=值;

注意***：键值对集合当中，键必须是唯一的，而值是可以重复的



8、var推断类型

﻿
125.Hashtable集合 P125 - 12:10
﻿

var：能够根据值推断出来类型



C#是一门强类型语言：在代码当中，必须对每一个变量的类型有一个明确的定义

//int n = 15;



js是一门弱类型语言：会根据值对类型做出判断（ps：B站就是因为使用了弱类型语言导致了一次崩溃。具体详见：BV18U4y1B7nA）

//12   3.14   true   "fdfds"   'c'   都能用var



9、foreach循环

语法：

foreach (var item in collection) {

}

//item表示集合中元素的标识符，collection表示集合



四、



1、Path类

﻿
127.Path类 P127 - 03:28
常用Path.Get方法
﻿

常用的Path.方法：

//获得文件名

Path.GetFileName(str);

//获得文件名但是不包含拓展名

Path.GetFileNameWithoutExtension();

//获得文件的拓展名

Path.GetExtension();

//获得文件所在的文件夹的名称

Path.GetDirectoryName();

//获得文件的全路径

Path.GetFullPath();

//连接两个字符串作为路径

Path.Combine(@"c:\a\" , "b.txt");



2、绝对路径和相对路径

绝对路径：通过给定的这个路径直接能在我的电脑中找到这个文件

相对路径：文件相对于应用程序的路径

结论：我们在开发中应该去尽量的使用相对路径



3、编码

文本文件有许多不同的编码格式，是为了显示不同的字符所诞生的，从最开始的ASCII到现在最常用的UTF-8，多样的的编码格式还造成读取时出现的各种乱码。关于编码格式有许多有趣的故事，具体详见：

【锟斤拷 ⊠是怎样炼成的——中文显示“⼊”门指南【柴知道】】 https://www.bilibili.com/video/BV1cB4y177QR



4、File类

//创建一个文件

//File.Create(@"盘符:\路径\文件名.拓展名");



//删除一个文件

//File.Delete();



//复制一个文件

File.Copy(@“盘符:\路径\要复制的文件名.拓展名” , @"盘符:\路径\复制后的文件名.拓展名")



//将字节数组中的每一个元素按照指定的编码格式解码成字符串

File.ReadAllBytes(@"文件的路径");



//将字符串转换成字节数组

Encoding.Default.GetBytes (str);



//将字节数组中的每一个元素写入到文件中

//没有这个文件的话，会给你创建一个，有的话会给你覆盖掉

File.WriteAllByte(@"‪C:\Users\UserName\Desktop\New.txt", 字节数组名)



//使用指定的编码读取文件的所有行，返回一个字符串数组

File.ReadAllLines(@"‪C:\Users\UserName\Desktop\New.txt", Encoding.Defalt)

//对应的，写入一个文件，以一个字符串数组的一个元素为一行，一行一行写入

File.WritelineAllLines(string path, str[]);



//使用指定的编码读取文件的所有行，返回一个字符串

File.ReadAllText(string path,encoding edition);

//相对的，写入字符串到一个文件

File.WriteAllText(string path, str)



//添加文本，不会覆盖源文件的内容

AppendAllLines();

AppendAllText();

AppendText();



读取音乐、视频、图片等多媒体图片文件用ReadAllBytes()

读取文本文件用ReadAllLine()或ReadAllText()



5、List泛型集合可以数组互相转换



6、装箱、拆箱

装箱：就是将值类型转换为引用类型

拆箱：将引用类型转换为值类型

看两种类型是否发生了装箱或者拆箱，要看这两种类型是否存在继承关系

例：

string str = "123";

int n = Convert.ToInt32(str);

//这个地方没有发生任何类型的装箱或者拆箱



7、文件流FileStream

﻿
137.使用FileStream来读写文件 P137 - 00:00
﻿

FileStream   操作字节的

StreamReader和StreamWriter   操作字符的



将创建文件流对象的过程写在using当中，会自动的帮我们释放流所占用的资源



五、多态

﻿
140.多态之虚方法 P140 - 00:00
﻿



概念：让一个对象能够表现出多种的状态（类型）

实现多态的3中手段：1、虚方法 2、抽象类 3、接口



1）虚方法

步骤：使用关键字 virtual，将父类的方法标记为虚方法，之后这个函数可以被子类用 override 重写



2）抽象类

当父类中的方法不知道如何去实现的时候，可以考虑将父类写成抽象类，将方法写成抽象方法

特点：

抽象成员必须标记为 abstract，并且不能有任何实现。
抽象成员必须在抽象类中
抽象类不能被实例化
子类继承抽象类后，必须把父类中的所有抽象成员重写（除非子类也是一个抽象类）
抽象成员的访问修饰符不能是 private
在抽象类中可以包含实例成员，并且抽象类的实例成员可以不被子类实现
抽象类是有构造函数的虽然不能被实例化
如果父类的抽象方法中有参数，那么，继承这个抽象类的子类在重写父类方法的时候，也必须传入返回值
======

如果父类中的方法有默认的实现，并且父类需要被实例化，这时可以考虑将父类定义成一个普通类，用虚方法来实现多态

如果父类中的方法没有默认实现，父类也不需要被实例化，则可以将该类定义为抽象类



一、访问修饰符

1、C#中的访问修饰符

public：公开的、公共的

private：私有的，只能在当前程序集中访问

internal：只能在当前程序集中访问。在同一个项目中，internal和public的权限时一样的

protected internal：



1）、能够修饰类的访问修饰符只有两个：public、internal

2）、可访问性不一致

子类的访问权限不能高于父类的访问权限，这样做会暴露父类的成员



二、设计模式

设计这个项目的一种方式



三、简单工厂设计模式



四、值类型在复制的时候，传递的是这个值本身

       引用类型在复制的时候，传递的是这个对象的引用





﻿
149.序列化和反序列化 P149 - 00:47
﻿

五、序列化：就是将对象转换为二进制

       反序列化：就是将二进制转换为对象

       作用：传输数据

序列化过程：

1）、用 [Serializable] 将这个类标记为可以被序列化的



六、partial 部分类

就是把一个类分在不同的地方写



七、sealed 密封类

不能被其他类继承，但是可以继承于其它类



八、接口

语法：

[public] interface I..able

{

	成员;

}

接口的特点：

接口是一种规范
只要一个类继承了一个接口，这个类就必须实现这个接口中所有的成员
为了多态，接口不能被实例化也就是说，接口不能被new（不能创建对象）
接口中的成员不允许添加访问修饰符，默认就是public，不能修改
（默认为public）接口中的成员不能有任何实现（“光说不做”，只是定义了一组未实现的成员）
接口中只能有方法、属性、索引器、使劲按，不能有“字段”和构造函数
接口与接口之间可以继承，并且可以多继承
接口并不能去继承一个类，而类可以继承接口（接口只能继承于接口，而类既可以继承接口，也可以继承类）
实现接口的子类必须实现接口的全部成员
一个类可以同时继承一个类并实现多个接口，如果一个子类同时继承了父类A，并实现了接口IA，那么语法上A必须写在IA的前面。class MyClass:A,IA {}  因为类是单继承的
显示实现接口的目的：解决方法的重名问题
什么时候使用显示实现接口：当继承的接口中的方法和参数一模一样的时候，要使用显示的实现接口
当一个抽象类实现接口的时候，需要子类去实现接口